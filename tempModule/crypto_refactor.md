Конечно. Вот финальная, обновленная версия технической документации в формате Markdown.

Я учел все наши последние решения и отразил в ней финальную архитектуру вашего протокола, объяснив все ключевые компромиссы и дизайнерские решения.

---

## Техническая Документация: Модуль Шифрования `eckWms-crypto`

### 1. Обзор и Назначение

Модуль `eckWms-crypto` предоставляет набор функций для двустороннего преобразования конфиденциальных данных в защищенный, компактный и URL-совместимый формат. Основное назначение модуля — кодирование идентификационной информации для использования в QR-кодах, которые имеют строгие ограничения по объему данных.

Протокол разработан с учетом следующих ключевых требований:

1.  **Компактность:** Итоговый URL должен умещаться в QR-код **версии 3, уровня L**, что накладывает ограничение в **77 символов** для данных в режиме **Alphanumeric**.
2.  **Безопасность:** Протокол обеспечивает **конфиденциальность** (данные нельзя прочитать), **целостность** (данные нельзя незаметно изменить) и **аутентичность** (данные созданы доверенным источником).
3.  **Контекстная Привязка:** Каждое сообщение криптографически привязано к конкретному пользователю и домену.
4.  **Емкость Данных:** Протокол спроектирован для безопасной передачи **19-байтной полезной нагрузки**.

### 2. Архитектура Протокола

В основе протокола лежит концепция создания единого **40-байтового бинарного крипто-блока**. Этот размер был выбран для идеального, без потерь, кодирования в **64 символа** с помощью кастомного алфавита Base32, который совместим с Alphanumeric-режимом QR-кодов.

#### 2.1. Структура Итогового URL

```
[ДОМЕН]/[КРИПТО-БЛОК][ID ПОЛЬЗОВАТЕЛЯ]
\______/ \__________/\_____________/
    |          |             |
 9 символов  64 символа   3-4 символа
(Пример)    (Base32)      (Alphanumeric)
```
**Общая длина:** 76-77 символов, что точно соответствует лимиту.

#### 2.2. Структура 40-байтового Крипто-блока

Это сердце протокола. Пакет собран для максимальной эффективности передачи, где передается только та информация, которую невозможно вычислить на принимающей стороне.

| Смещение (байт) | Длина (байт) | Назначение | Описание |
| :--- | :--- | :--- | :--- |
| **0 - 8** | **9** | **Nonce** | Уникальная, случайно сгенерированная часть Вектора Инициализации (IV). |
| **9 - 27** | **19** | **Шифротекст** | Зашифрованная 19-байтная полезная нагрузка. |
| **28 - 39** | **12** | **Урезанный Тег** | Тег аутентификации, урезанный до 12 байт для экономии места. |

#### 2.3. Криптографические Примитивы и Компромиссы

*   **Алгоритм:** `aes-192-gcm`. Современный стандарт шифрования с аутентификацией (AEAD).
*   **Ключ:** `2f8...2d2` (192 бита / 24 байта). Жестко задан в модуле.
*   **Вектор Инициализации (IV):** **12 байт (96 бит)**. Используется "золотой стандарт" NIST для AES-GCM, обеспечивающий максимальную производительность. Он **не передается целиком**, а вычисляется "на лету".
*   **Тег Аутентификации (Подпись):** **12 байт (96 бит)**. Это **осознанный компромисс**. Стандартный 16-байтовый тег был урезан до 12 байт, чтобы вместить 19-байтную полезную нагрузку. Этот уровень защиты (1 шанс на 2^96) все еще является чрезвычайно высоким и соответствует рекомендациям NIST для большинства приложений.

### 3. Детальное Описание Функций

#### `betrugerUrlEncrypt(payloadBuffer19, userId, domain)`

Эта функция выполняет процесс "шифрования и упаковки".

**Входные данные:**
*   `payloadBuffer19`: Строго **19-байтный** `Buffer`, содержащий полезную нагрузку (например, 1 байт префикса + 18 байт данных).
*   `userId`: Идентификатор пользователя (например, "M3A").
*   `domain`: Идентификатор домена (например, "ECK1.COM").

**Процесс выполнения:**

1.  **Вычисление полного IV (12 байт):**
    *   **Контекстная часть (3 байта):** Создается хеш `SHA256` от строки `userId + domain`. Первые 3 байта этого хеша берутся как криптографический "отпечаток" контекста.
    *   **Уникальная часть (Nonce, 9 байт):** Генерируются 9 байт случайных данных с помощью `crypto.randomBytes()`.
    *   Обе части склеиваются, образуя **12-байтовый** вектор, который будет передан в шифратор.
2.  **Шифрование:**
    *   Инициализируется шифратор `aes-192-gcm` с ключом и вычисленным 12-байтовым IV.
    *   19-байтный payload шифруется, в результате чего получается 19-байтовый шифротекст.
3.  **Получение и Урезание Тега:**
    *   Из шифратора извлекается полный 16-байтовый тег аутентификации.
    *   Тег **урезается до 12 байт**.
4.  **Сборка и Кодирование Пакета:**
    *   Формируется итоговый **40-байтовый пакет** в порядке: `[9-байтовый Nonce] + [19-байтовый Шифротекст] + [12-байтовый урезанный Тег]`.
    *   Этот 40-байтовый пакет кодируется в 64-символьную строку с помощью функции `betrugerToBase32`.
5.  **Формирование URL:** Возвращается финальная строка, состоящая из домена, слэша, 64-символьного крипто-блока и ID пользователя.

#### `betrugerUrlDecrypt(betrugerUrl)`

Эта функция выполняет обратный процесс "распаковки и проверки".

**Входные данные:**
*   `betrugerUrl`: Полный URL, сгенерированный предыдущей функцией.

**Процесс выполнения:**

1.  **Парсинг URL:** URL разбирается на три компонента: домен, 64-символьный крипто-блок и ID пользователя.
2.  **Декодирование Пакета:** 64-символьный крипто-блок декодируется из Base32 обратно в **40-байтовый** бинарный пакет.
3.  **Разбор Пакета:** Пакет разбирается на составляющие: 9-байтовый **nonce**, 19-байтовый **шифротекст** и 12-байтовый **урезанный тег**.
4.  **Восстановление полного IV:**
    *   Сервер выполняет ту же операцию, что и клиент: вычисляет **3-байтовую контекстную часть** из полученных `userId` и `domain`.
    *   Эта контекстная часть склеивается с **полученным 9-байтовым nonce**, в результате чего восстанавливается **точная копия 12-байтового IV**, который использовался для шифрования.
5.  **Расшифровка и Верификация:**
    *   Инициализируется дешифратор `aes-192-gcm` с ключом и восстановленным 12-байтовым IV.
    *   **Полученный 12-байтовый тег** устанавливается на дешифратор (`decipher.setAuthTag()`).
    *   Выполняется попытка расшифровать шифротекст. На этом этапе `crypto` неявно вычисляет свой собственный тег и сравнивает его с тем, который был установлен. Если теги не совпадают, функция `decipher.final()` выбрасывает ошибку, что свидетельствует о нарушении целостности данных.
6.  **Возврат результата:**
    *   В случае успешной расшифровки, функция возвращает **19-байтный** бинарный `Buffer` с исходной полезной нагрузкой.
    *   В случае любой ошибки (неверный формат, ошибка расшифровки) возвращается `false`.
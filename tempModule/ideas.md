

# Файл идей для проекта eckwms

Этот документ содержит сборник идей, архитектурных решений и потенциальных улучшений для системы управления складом eckwms.

## 1. Архитектурные принципы

* **Гибридная модель хранения:** Использовать многоуровневую архитектуру баз данных для обеспечения отказоустойчивости и производительности:
    * **Локальные клиенты (`eckWms`, `ecKasse`):** **SQLite** для полной автономной работы.
    * **Центральный сервер:** **PostgreSQL** для агрегации данных, резервного копирования и надёжного хранения.
    * **Веб-сервис (Marketplace):** Гибрид **PostgreSQL** (источник правды) и **Valkey/Redis** (кэширование, сессии, оперативные данные) для максимальной производительности.

## 2. Стратегия использования штрихкодов

Внедрить двухконтурную систему штрихкодов, разделяя публичное и внутреннее использование для повышения безопасности и решения маркетинговых задач.

### 2.1. Публичные коды (для товаров)

* **Формат:** Стандартный **QR-код**.
* **Назначение:** Размещение на конечных продуктах для клиентов. Является элементом маркетинга и предоставляет публичную информацию.
* **Содержимое:** Только публичные данные, предпочтительно URL на страницу продукта, инструкцию или рекламный сайт. **Не должен содержать зашифрованные блоки.**

### 2.2. Внутренние коды (для логистики)

* **Формат:** **Aztec-код**. Выбран за счёт большей плотности данных и устойчивости к повреждениям, что идеально для складских условий.
* **Назначение:** Идентификация всех внутренних логистических единиц: палеты, коробки, места хранения, уникальные товары на складе.
* **Размер и восстановление:** Использовать фиксированный размер **Aztec 31x31** с максимально возможным уровнем восстановления данных.
    * Для записи "полного" 47-байтного (376-битного) криптографического пакета это позволяет достичь уровня коррекции ошибок (ECC) примерно **72%**.

## 3. Улучшения безопасности (Подтверждение владения)

Внедрить динамические методы подтверждения владения для сценариев поддержки клиентов с дорогостоящими товарами.

### 3.1. Основная идея: Криптографические RFID/NFC метки

* **Технология:** Использовать RFID/NFC метки со встроенным чипом, способным выполнять симметричные криптографические операции.
* **Процесс:** Реализовать механизм "Вызов-Ответ":
    1.  Сервер генерирует случайный "вызов".
    2.  Клиент подносит телефон к NFC-метке.
    3.  Метка, используя свой уникальный секретный **симметричный ключ**, вычисляет "ответ" и передаёт его на телефон. Секретный ключ при этом не раскрывается.
    4.  Клиент сообщает "ответ" сотруднику поддержки.
    5.  Сервер, зная секретный ключ метки, проверяет корректность ответа.
* **Преимущества:** Высокая безопасность (невозможно скопировать сфотографировав), отличное удобство для пользователя.

### 3.2. Альтернативная идея: Таблица "Вызов-Ответ" на наклейке

* **Технология:** Печатная, уникальная для каждого товара сетка символов.
* **Процесс:** Сотрудник поддержки сообщает случайные координаты, а клиент находит и называет соответствующие символы.
* **Преимущества:** Не требует электроники, лучше, чем статические QR-коды.
* **Недостатки:** Уязвимо к фотографированию (злоумышленник получает всю таблицу).

## 4. Бэкенд и рефакторинг базы данных

* **Завершить миграцию на PostgreSQL:** Приоритетная задача для повышения стабильности и масштабируемости системы.
    * **Удалить глобальные переменные:** Полностью отказаться от использования глобальных переменных (`global.users`, `global.orders` и т.д.) для хранения данных в пользу запросов к PostgreSQL.
    * **Рефакторинг `logOut`:** Переписать функцию `logOut` в `app.js` так, чтобы она корректно закрывала соединение с БД и выполняла другие необходимые процедуры чистого завершения работы, убрав логику сохранения данных в JSON-файлы.
    * **Обеспечить безопасность API:** Добавить middleware аутентификации (например, `requireAuth`) для всех служебных эндпоинтов, включая `/api/scan`.

## 5. Тестирование и DevOps

* **Интегрировать фреймворк для тестирования:** Добавить в проект Jest или Vitest для автоматизации тестирования.
* **Разработать тесты:** Создать набор тестов, покрывающих:
    * **Unit-тесты:** для критически важных утилит (`encryption.js`, `scanHandler.js`, `formatUtils.js`).
    * **Интеграционные тесты:** для всех маршрутов API, проверяя корректность ответов и обработку ошибок.
    * **Тесты безопасности:** для проверки работы middleware аутентификации и авторизации.
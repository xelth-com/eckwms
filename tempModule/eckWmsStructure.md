Отлично. Давайте начнем документировать эту сложную, но элегантную систему. Вот первая часть документации, посвященная именно структуре данных и классам, которые вы определили в `eckwms.js`.

---

## Техническая Документация eckWms: Структура Данных

### 1. Обзор

Система `eckWms` оперирует набором взаимосвязанных сущностей, которые представляют физические и логические объекты в процессе управления складом и ремонтами. В основе архитектуры лежит объектно-ориентированный подход с использованием классов для определения структуры и поведения каждой сущности.

Все сущности наследуются от базового класса `Betruger`, что обеспечивает общую структуру для ключевых атрибутов.

### 2. Базовый класс: `Betruger`

`Betruger` является прародителем всех основных объектов системы. Он определяет фундаментальные свойства, общие для любого отслеживаемого элемента.

#### Свойства класса `Betruger`:

| Свойство | Тип | Описание | Пример |
| :--- | :--- | :--- | :--- |
| `cl` | `string` | **Имя Класса/Типа:** Определяет класс или тип объекта, например, "M3-SM10" или "Аккумулятор". | `'m3-sm10-l'` |
| `mod` | `string` | **Модификация:** Уточнение конкретной версии или модификации объекта. | `'rev1.2'` |
| `sn` | `array` | **Серийный Номер:** Массив, где `sn[0]` - основной уникальный идентификатор, а `sn[1]` - Unix-время создания. | `['i12345678', 1677628800]` |
| `pn` | `array` | **Парт-номер (Part Number):** Массив пар `[номер, поставщик]`. | `[['GH96-12345A', 'samsung']]` |
| `cond`| `array` | **Состояние:** История изменений состояния объекта, например, "OK", "NOK". | `[['OK', 1677628800]]` |
| `actn`| `array` | **Действия (Actions):** Лог выполненных действий, массив троек `[тип, сообщение, время]`. | `[['check', 'Display OK', 1677715200]]` |
| `desc`| `array` | **Описание:** Массив текстовых описаний или заметок с временными метками. | `[['Царапина на корпусе', 1677628800]]` |
| `brc` | `array` | **Баркоды:** Список всех ассоциированных (несистемных) баркодов, отсканированных для этого объекта. | `['1Z12345E0205271688']` |
| `img` | `array` | **Изображения:** Массив URL-адресов изображений объекта. | `['/storage/img/sm10_front.png']` |
| `mas` | `array` | **Масса:** История измерений массы в килограммах. | `[[0.185, 1677628800]]` |
| `siz` | `array` | **Размеры:** История измерений размеров (Д, Ш, В) в сантиметрах. | `[[[14.5, 7.2, 0.9], 1677628800]]` |
| `own` | `array` | **Владелец:** История владения объектом. | `[['u12345', 1677628800]]` |

### 3. Производные классы

#### 3.1. `Item` - Товар/Устройство

Представляет собой единичный, атомарный объект — обычно устройство, компонент или деталь. Наследует все свойства `Betruger` и добавляет специфичные для него.

**Дополнительные свойства:**
*   `loc` (`array`): История местоположений. Запись - это пара `[id_контейнера, время]`, где контейнером может быть `Box` или `Place`.
*   `prc` (`array`): История цен.
*   `mult` (`array`): Данные для мультипликации (создания множества копий).
*   `up`, `down` (`array`): Связи в иерархии (например, `up` - родительский класс, `down` - дочерние экземпляры).
*   `attr` (`object`): Набор произвольных атрибутов (ключ-значение).
*   `prop` (`array`): Определенные свойства, такие как материал или цвет.
*   `rel` (`array`): Определенные отношения, такие как "часть от" (`partOf`) или "предназначен для" (`purpose`).

#### 3.2. `Box` - Коробка/Контейнер

Представляет собой физический контейнер, который может содержать `Item`'ы или другие `Box`'ы.

**Дополнительные свойства:**
*   `in`, `out` (`array`): Логи входящих и исходящих транзакций (например, привязка к заказу).
*   `cont` (`array`): **Содержимое.** Список `Item`'ов или `Box`'ов, находящихся внутри. Запись - пара `[id_объекта, время_добавления]`.
*   `mult` (`array`): Данные для мультипликации.
*   `loc` (`array`): История местоположений. Может находиться в `Place` или в другом `Box`.
*   `prc` (`array`): История цен.

#### 3.3. `Place` - Место на складе

Представляет собой физическое местоположение на складе (полка, стеллаж, палета).

**Дополнительные свойства:**
*   `cont` (`array`): **Содержимое.** Список `Item`'ов или `Box`'ов, размещенных в этом месте.

#### 3.4. `Order` - Заказ

Представляет собой логическую сущность заказа (например, RMA-заказ).

**Дополнительные свойства:**
*   `cust`, `comp`, `pers`, `str`, `hs`, `zip`, `ctry`, `cit`, `cem`, `iem`, `ph`: Подробная информация о клиенте и адресе.
*   `cont` (`array`): Список `Box`'ов, связанных с этим заказом.
*   `decl` (`array`): Декларация — список ожидаемых `Item`'ов по этому заказу с их описаниями.

#### 3.5. `User` - Пользователь

Представляет собой пользователя системы или клиента.

**Дополнительные свойства:**
*   `cont` (`array`): Список объектов, принадлежащих этому пользователю.

---
Эта структура данных является ядром системы, обеспечивая гибкое и подробное отслеживание каждого объекта на всех этапах его жизненного цикла. Дальше мы можем описать, как эти объекты взаимодействуют и как их идентификаторы кодируются с помощью криптографического модуля.





Отлично, продолжаем. Теперь, когда у нас есть четкое понимание структуры данных, мы можем описать, как система идентифицирует и защищает эти объекты с помощью нашего финального, продуманного протокола.

---

### 4. Универсальный Идентификатор eckWms (19 байт)

Каждый уникальный объект в системе (`Item`, `Box`, `Place`) получает собственный **Универсальный Идентификатор**. Это не просто серийный номер, а сложная 19-байтная (152-битная) структура данных, которая является "цифровым паспортом" объекта.

Эта структура разработана для максимальной эффективности и передается внутри криптографического пакета.

#### 4.1. Архитектура Идентификатора (`1+18` байт)

Идентификатор состоит из двух логических частей:
1.  **Префикс-Байт (1 байт):** Первый байт, содержащий метаданные о полезной нагрузке.
2.  **Контейнер Данных (18 байт):** Оставшиеся 18 байт, содержащие сами данные в одном из нескольких форматов.

#### 4.2. Структура Префикс-Байта

Префикс-байт — это "карта" для чтения всего идентификатора. Его 8 бит разделены на три поля для хранения метаданных.

**Структура:** `[ EE SSS OOO ]` (E - Encoding, S - Size, O - Object)

| Биты (от старшего) | Длина (бит) | Поле | Описание и Значения |
| :--- | :--- | :--- | :--- |
| **7, 6** | **2** | **ТИП КОДИРОВКИ (Encoding)** | Определяет, как интерпретировать 18-байтный контейнер данных. |
| **5, 4, 3**| **3** | **РАЗМЕР ДАННЫХ (Size)** | Указывает, сколько байт из 18-байтного контейнера реально занято полезными данными. |
| **2, 1, 0**| **3** | **ТИП ОБЪЕКТА (Object)** | Указывает, к какому классу (`Item`, `Box` и т.д.) относится данный идентификатор. |

**Значения полей:**

1.  **ТИП ОБЪЕКТА (`OOO`):**
    *   `000` (0): **Item**
    *   `001` (1): **Box**
    *   `010` (2): **Place**
    *   `011` (3): **Order**
    *   `100` (4): **User**

Вы правы, это было важное уточнение. Ориентироваться на стандартные и общепринятые форматы, такие как Base64, — это всегда более надежный путь.

Давайте еще раз перепишем этот пункт, сделав `Base64` основным текстовым форматом и убрав специфичный `code32`.



2. ТИП КОДИРОВКИ (`EE`):

Это поле определяет, как следует интерпретировать 18-байтный контейнер данных. Порядок значений выбран для наиболее частого использования.

*   `00` (0): **Числовой (`Numeric`)**
    *   **Описание:** Для хранения очень длинных числовых идентификаторов. 18 байт используются для хранения одного большого беззнакового целого числа (`BigInt`). Этот режим наиболее эффективен для системных серийных номеров.
    *   **Максимальная емкость:** Одно число до `2^(18*8) - 1` (что больше `10^43`).
    *   **Пример использования:** Внутренние серийные номера `Item`, `Box`, `Place`.

*   `01` (1): **Base64url-совместимая строка (`URL-safe Text`)**
    *   **Описание:** **Основной режим** для хранения текстовых идентификаторов. Данные представляют собой строку, состоящую только из символов URL-safe Base64 (`A-Z`, `a-z`, `0-9`, `-`, `_`).
    *   **Максимальная емкость:** Строка длиной до **18 символов**.
    *   **Пример использования:** Внешние идентификаторы, артикулы, парт-номера (`i453Sfdfke48`, `box-b543-variant_A`).

*   `10` (2): **UTF-8 строка (`Unicode`)**
    *   **Описание:** Для хранения текста с любыми символами, включая умлауты, кириллицу и другие символы Unicode. Этот режим обеспечивает максимальную гибкость для нестандартных данных.
    *   **Максимальная емкость:** Переменная. Зависит от используемых символов (например, до 18 для латиницы, до 9 для кириллицы).
    *   **Пример использования:** Описания, содержащие специальные символы (`box-ä543`).

*   `11` (3): **Зарезервировано (`Reserved`)**
    *   **Описание:** Этот код зарезервирован для будущего использования. Потенциально может быть использован для бинарных данных (`binary/octet-stream`) или других специфичных форматов.

3.  **РАЗМЕР ДАННЫХ (`SSS`):**
    *   Указывает размер полезной нагрузки внутри 18-байтного контейнера, что позволяет эффективно хранить данные переменной длины.
    *   `000`: 2 байта
    *   `001`: 4 байта
    *   `010`: 6 байт
    *   `011`: 8 байт (стандарт для `UInt64`)
    *   `100`: 10 байт
    *   `101`: 12 байт
    *   `110`: 16 байт
    *   `111`: 18 байт (полный контейнер)

### 5. Криптографическая Защита Идентификатора

Чтобы обеспечить безопасность и целостность, каждый 19-байтный Универсальный Идентификатор шифруется перед использованием (например, для генерации QR-кода). Для этого используется криптографический модуль `eckWms-crypto`.

#### 5.1. Процесс Шифрования

1.  **Подготовка:** Формируется 19-байтный идентификатор, как описано выше.
2.  **Вычисление IV:** Генерируется **12-байтовый Вектор Инициализации**, состоящий из:
    *   **3 байт контекста:** `SHA256(ID_пользователя + Домен)`.
    *   **9 байт случайности (nonce)**.
3.  **Шифрование:** 19-байтный идентификатор шифруется с помощью `aes-192-gcm`, используя вычисленный IV.
4.  **Урезание Тега:** Для экономии места, стандартный 16-байтовый тег аутентификации **урезается до 12 байт**.
5.  **Сборка Пакета:** Формируется **40-байтовый крипто-блок**: `[9-байт Nonce] + [19-байт Шифротекст] + [12-байт Тег]`.
6.  **Кодирование:** 40-байтовый пакет кодируется в 64-символьную Base32-строку.
7.  **Формирование URL:** Создается финальный URL, который готов для генерации QR-кода.

#### 5.2. Процесс Расшифровки

1.  **Разбор:** Из URL извлекаются домен, ID пользователя и 64-символьный крипто-блок.
2.  **Декодирование и Разбор Пакета:** Крипто-блок декодируется в 40-байтовый пакет и разбирается на `Nonce`, `Шифротекст` и `Тег`.
3.  **Восстановление IV:** На основе `Nonce` и контекста (ID пользователя, домен) восстанавливается полный 12-байтовый IV.
4.  **Верификация и Расшифровка:** Происходит попытка расшифровать данные. Если тег не совпадает (данные были подделаны), процесс прерывается.
5.  **Возврат Идентификатора:** В случае успеха возвращается исходный 19-байтный Универсальный Идентификатор.

Этот двухступенчатый процесс — сначала создание структурированного идентификатора, а затем его криптографическая "обертка" — позволяет системе быть одновременно гибкой в управлении данными и абсолютно надежной в их передаче и хранении.


Отлично. Вот финальный раздел документации, описывающий вашу продуманную, многоуровневую архитектуру хранения данных. Этот текст можно добавить в конец вашего файла `ideasHistory.md`.

---

## 13. Архитектура Хранения Данных: От Локальной Автономности до Облачной Масштабируемости

**Цель:** Обеспечить правильный баланс между автономностью, надежностью, производительностью и масштабируемостью для каждой части экосистемы (`eckWms`, `ecKasse`, `Meduza Marketplace`), используя наиболее подходящий инструмент для каждой конкретной задачи.

**Принцип:** Система строится на **гибридной, многоуровневой модели**, где разные типы баз данных используются для решения разных проблем, избегая подхода "одно решение для всего".

---

### 13.1. Уровень 1: Локальные Системы (`eckWms` и `ecKasse`)

Этот уровень спроектирован по принципу **"Оффлайн-First"** для обеспечения максимальной отказоустойчивости на местах.

*   **Основная База Данных:** **SQLite**
    *   **Роль:** "Источник правды" для конкретной точки продаж или склада. Хранит все оперативные данные: товары, остатки, транзакции, настройки, локальные логи.
    *   **Размещение:** В виде локального файла (`.sqlite`) на том же устройстве, где работает приложение (`ecKasse-client-desktop` или `eckWms`).
    *   **Обоснование выбора:**
        1.  **Автономность:** Гарантирует полную работоспособность системы без подключения к интернету.
        2.  **Надежность:** Обеспечивает ACID-транзакции, защищая данные от повреждения при сбоях питания или ошибках ПО. Это на порядок надежнее хранения в JSON-файлах.
        3.  **Простота развертывания (Zero-Configuration):** Не требует установки, настройки или администрирования отдельного сервера баз данных, что идеально для десктопных приложений.
        4.  **Производительность:** Для локальных операций, где нет сетевых задержек, скорость SQLite является более чем достаточной.
    *   **Взаимодействие:** Локальный бэкенд-демон (`ecKasse-backend`) работает исключительно с этим SQLite файлом.

---

### 13.2. Уровень 2: Центральный Сервер (`eckX.com`)

Этот уровень служит для агрегации, резервного копирования и предоставления централизованных сервисов для множества локальных инсталляций.

*   **Основная База Данных:** **PostgreSQL**
    *   **Роль:** Центральное, долгосрочное хранилище агрегированных данных.
    *   **Размещение:** На защищенных серверах `eckX.com`.
    *   **Задачи:**
        *   **Резервное копирование:** Прием и хранение резервных копий локальных SQLite баз данных.
        *   **Агрегация отчетов:** Сбор данных о продажах со всех точек для построения сводной аналитики, доступной администраторам (например, через веб-интерфейс).
        *   **Централизованные справочники:** Хранение "мастер-версии" каталога товаров, который может синхронизироваться с локальными базами.
        *   **Absicherung (Якорение целостности):** Может служить точкой для сбора и публикации криптографических хэшей для подтверждения неизменности данных.
    *   **Обоснование выбора:**
        1.  **Масштабируемость и Конкурентность:** PostgreSQL создан для обработки одновременных запросов от множества клиентов, что необходимо для центрального сервера.
        2.  **Мощность и Гибкость:** Поддерживает сложные SQL-запросы, агрегацию, а также продвинутые типы данных (например, `JSONB`), что идеально подходит для аналитических задач.
        3.  **Надежность:** Является промышленным стандартом для надежного, транзакционного хранения данных.

---

### 13.3. Уровень 3: Высокопроизводительный Веб-Сервис (`Meduza Marketplace`)

Этот уровень требует максимальной производительности и отзывчивости для обслуживания большого количества онлайн-пользователей. Здесь применяется **гибридная архитектура**.

*   **Основная База Данных ("Источник Правды"):** **PostgreSQL**
    *   **Роль:** Та же, что и на центральном сервере — надежное хранение фундаментальных данных: профили пользователей, каталог товаров, история заказов, платежные транзакции.

*   **Высокоскоростной кэш и оперативные данные:** **Valkey** (как Open Source аналог Redis)
    *   **Роль:** "Ускоритель" и "оперативный штаб", работающий в памяти для мгновенного отклика.
    *   **Размещение:** На серверах маркетплейса, рядом с PostgreSQL.
    *   **Задачи:**
        *   **Управление сессиями:** Хранение информации о залогиненных пользователях.
        *   **Кэширование:** Временное хранение часто запрашиваемых данных (страницы товаров, списки категорий), чтобы снизить нагрузку на PostgreSQL.
        *   **Оперативные данные:** Управление состоянием корзин покупок, быстрыми счетчиками ("просмотрено N раз").
        *   **Очереди задач:** Обработка фоновых задач, таких как отправка email-уведомлений.
    *   **Обоснование выбора:**
        1.  **Скорость:** Valkey/Redis обеспечивает субмиллисекундное время ответа для операций в памяти.
        2.  **Специализированные структуры данных:** Предоставляет идеальные инструменты (Sets, Hashes, Lists) для решения задач кэширования, сессий и очередей.
        3.  **Снижение нагрузки:** Значительно снижает количество запросов к основной базе данных, позволяя ей заниматься более сложными задачами.

### Итоговая схема:

| Система | Основная БД | Кэш / Оперативные данные | Ключевой принцип |
| :--- | :--- | :--- | :--- |
| **`eckWms` / `ecKasse` (Локально)** | **SQLite** | Встроенные механизмы (RAM) | Автономность и простота |
| **Центральный сервер (`eckX.com`)** | **PostgreSQL**| (Не требуется) | Агрегация и надежность |
| **`Meduza Marketplace` (Веб)** | **PostgreSQL**| **Valkey / Redis** | Производительность и масштабируемость |
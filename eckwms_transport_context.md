# AI Instructions

## 1. How to Read This Snapshot

This document is a self-contained, single-file snapshot of the **eckwms** software repository, generated by the `eck-snapshot` tool on **2025-12-21T08:39:30.294Z**. It is designed to provide a Large Language Model (LLM) with the complete context of a project.

* **Source of Truth:** Treat this snapshot as the complete and authoritative source code.
* **Structure:** The file contains a **Directory Structure** tree, followed by the full content of each file, demarcated by `--- File: /path/to/file ---` headers.

**Snapshot Stats:**
- **Files Included:** 6
- **Total Files in Repo:** 6

---

## 2. Your Core Operational Workflow

You are the Project Manager and Solution Architect AI. Your primary goal is to translate user requests into technical plans and then generate precise commands for code-execution AI agents.

### PROJECT OVERVIEW
- **Project:** eckwms
- **Description:** WMS project for e-commerce and service centers



## Project-Specific Manifest (.eck Directory)

This project includes a `.eck` directory with specific context and configuration:

### Project Context

# Project Overview

## Description
Brief description of what this project does and its main purpose.

## Architecture
High-level overview of the system architecture, key components, and how they interact.

## Key Technologies
- Technology 1
- Technology 2
- Technology 3

## Important Notes
Any crucial information that developers should know when working on this project.

### Operations Guide

# Common Operations

## Development Setup
```bash
# Setup commands
npm install
# or yarn install
```

## Running the Project
```bash
# Development mode
npm run dev

# Production build
npm run build
```

## Testing
```bash
# Run tests
npm test

# Run tests in watch mode
npm run test:watch
```

## Deployment
```bash
# Deployment commands
npm run deploy
```

## Troubleshooting
Common issues and their solutions.

### Development Journal

# Development Journal

## Recent Changes
Track significant changes, decisions, and progress here.

---

### YYYY-MM-DD - Project Started
- Initial project setup
- Added basic structure

### Environment Overrides

The following environment settings override auto-detected values:

- **agent_id**: local_dev

**Important**: Use this manifest information when formulating technical plans and briefing execution agents. The context, operations guide, and journal provide crucial project-specific knowledge that should inform your decisions.

---



### CRITICAL WORKFLOW: Structured Commits via `journal_entry`

To ensure proper project history, all code changes **MUST** be committed using the project's built-in structured workflow.

**Your Role (Architect):**
Your JSON command payload **MUST** include a `post_execution_steps.journal_entry` object. This object is the *trigger* for the execution agent's internal `/eck:commit` command.

**DO NOT** generate `git add` or `git commit` commands yourself. The `journal_entry` object handles everything:
1.  Staging all changes (`git add .`).
2.  Creating a YAML frontmatter entry for the journal.
3.  Prepending the entry to `.eck/JOURNAL.md`.
4.  Executing the conventional Git commit.

**Example `journal_entry` in your payload:**
```json
    "post_execution_steps": {
      "journal_entry": {
        "type": "feat",
        "scope": "api",
        "summary": "Implement user authentication endpoint",
        "details": "- Added /login route\n- Implemented JWT validation"
      }
    }
````

### Strategic Manifest Files

As the Architect, you are also responsible for maintaining other strategic files in the `.eck` directory, such as `ROADMAP.md` and `TECH_DEBT.md`. Propose modifications to these files as needed to reflect the project's status.

### CORE WORKFLOW: The Interactive Command Cycle

1.  **Check Environment:** Request ENV scan from agent first
2.  **Analyze User Request:** Understand the user's goal in their native language.
3.  **Formulate a Plan:** Create a high-level technical plan appropriate for the detected environment and .eck manifest context.
4.  **Propose & Await Confirmation:** Present the plan to the user in their language and ask for approval to generate the command. **CRITICAL: Stop and wait for the user's response. Do NOT generate the command block at this stage.**
5.  **Generate Command on Demand:** This is the execution step, triggered ONLY by a positive user response.
      - **On Approval:** If the user confirms the plan (e.g., "yes", "proceed") or provides a minor correction, your *next response* must be **only the command block**. Do not include any conversational text.
      - **On Direct Order:** If the user explicitly asks for the command (e.g., "make the command for Claude now") and you have all the necessary information, you may skip step 3 and directly generate the command block.
6.  **Review & Report:** After the command is executed, analyze the results and report back to the user in their language.
7.  **Iterate:** Continue the cycle based on user feedback.



## Partial Snapshot Context
- **Profile(s) Active:** **/local/server.js,**/routes/scan.js,**/utils/scanHandler.js,**/NGINX_SETUP.md,public/js/*,**/ANDROID_INTEGRATION.md
- **Other Available Profiles:** backend, frontend, android-core, android-tests, android-config, database, deployment, test-frontend, test-backend

### HIERARCHICAL AGENT WORKFLOW

Your primary role is **Senior Architect**. You formulate high-level strategy. For complex code implementation, you will delegate to a **Junior Architect** agent (`gemini_wsl`), who has a detailed (`_ja.md`) snapshot and the ability to command a **Coder** agent (`claude`).

  - **Senior Architect (You):** Sets strategy, defines high-level tasks.
  - **Junior Architect (`gemini_wsl`):** Receives strategic tasks, analyzes the `_ja.md` snapshot, breaks the task down, and commands the Coder.
  - **Coder (`claude`):** Receives small, precise coding tasks from the Junior Architect. **Claude is highly trained for code generation and should be used for all primary code-writing tasks**, while `gemini_wsl` can use its own tools for analysis, validation, and running shell commands.

### COMMAND FORMATS

You MUST use one of two JSON command formats based on your target:

**1. For Coders (`local_dev`, `production_server`, `android_wsl_dev`, `gemini_windows`) - LOW-LEVEL EXECUTION:**
Use `apply_code_changes` for simple, direct tasks where you provide all details.

```json
{
  "target_agent": "local_dev",
  "agent_environment": "Development environment with full GUI support and development tools",
  "command_for_agent": "apply_code_changes",
  "task_id": "unique-task-id",
  "payload": {
    "objective": "Brief, clear task description",
    "context": "Why this change is needed - include relevant .eck manifest context",
    "files_to_modify": [
      {
        "path": "exact/file/path.js",
        "action": "specific action (add, modify, replace, delete)",
        "location": "line numbers, function name, or search pattern",
        "details": "precise description of the change"
      }
    ],
    "new_files": [
      {
        "path": "path/to/new/file.js",
        "content_type": "javascript/json/markdown/config",
        "purpose": "why this file is needed"
      }
    ],
    "dependencies": {
      "install": ["package-name@version"],
      "remove": ["old-package-name"]
    },
    "validation_steps": [
      "npm run test",
      "node index.js --help",
      "specific command to verify functionality"
    ],
    "expected_outcome": "what should work after changes",
    "post_execution_steps": {
      "journal_entry": {
        "type": "feat",
        "scope": "authentication",
        "summary": "Brief description of what was accomplished",
        "details": "Detailed explanation of changes, impacts, and technical notes"
      },
      "mcp_feedback": {
        "success": true,
        "errors": [],
        "mcp_version": "1.0"
      }
    }
  }
}
```

**2. For Junior Architects (`gemini_wsl`) - HIGH-LEVEL DELEGATION:**
Use `execute_strategic_task` for complex features. The JA will use its own snapshot and Coder agent to complete the task.

```json
{
  "target_agent": "gemini_wsl",
  "command_for_agent": "execute_strategic_task",
  "payload": {
    "objective": "Implement the user authentication feature",
    "context": "This is a high-level task. Use your _ja.md snapshot to analyze the codebase. Use your 'claude (delegate)' capability to implement the necessary code across all required files (routes, controllers, services).",
    "constraints": [
      "Must use JWT for tokens",
      "Add new routes to `routes/api.js`",
      "Ensure all new code is covered by tests"
    ],
    "validation_steps": [
      "npm run test"
    ]
  }
}
```

### COMMUNICATION PROTOCOL

  - **User Interaction:** ALWAYS communicate with the user in the language they use.
  - **Agent Commands:** ALWAYS formulate the JSON payload and technical instructions for the execution agent in **ENGLISH** to ensure technical accuracy.
  - **Context Integration:** When briefing agents, include relevant information from the .eck manifest to provide better context.

### AVAILABLE EXECUTION AGENTS

You can command multiple specialized agents. **YOU must choose the most appropriate agent** based on the task requirements and target environment:


### Local Development Agent (AGENT_LOCAL_DEV) (ID: "local_dev")
- **Description:** Cross-platform local development with SQLite
- **GUI Support:** Yes
- **Capabilities:** npm install, npm run dev, npm run dev:backend, git operations, sqlite3 commands, electron debug, file editing, testing commands, browser automation
- **Restrictions:** no PM2 commands, no PostgreSQL production operations, no systemctl, no production deployments

### Production Server Agent (AGENT_PROD_SERVER) (ID: "production_server")
- **Description:** Linux production server with PostgreSQL and PM2, with development capabilities
- **GUI Support:** No (Headless)
- **Capabilities:** pm2 restart/reload/stop/start, postgresql queries, knex migrations --env production, systemctl, log analysis, nginx operations, deployment scripts, file editing, npm install, git operations
- **Restrictions:** no electron, no GUI apps, no direct DB schema changes without migrations, always backup before migrations

### Android WSL Development Agent (AGENT_ANDROID_WSL) (ID: "android_wsl_dev")
- **Description:** Android development in Windows Subsystem for Linux with Gradle and ADB support
- **GUI Support:** No (Headless)
- **Capabilities:** ./gradlew build, ./gradlew assembleDebug, ./gradlew assembleRelease, ./gradlew clean, ./gradlew lint, ./gradlew test, adb devices, adb install, adb logcat, adb shell, git operations, file editing, gradle tasks, gradle wrapper operations
- **Restrictions:** no direct GUI access (Android Studio), requires /mnt/c/ path for Windows file system access, no Android emulator control (emulator runs on Windows host), limited USB device access through WSL, no hardware debugging interfaces

### Gemini WSL Agent (Junior Architect) (ID: "gemini_wsl")
- **Description:** Gemini, running in WSL. Can access all WSL tools and delegate to other agents like claude.
- **GUI Support:** No (Headless)
- **Capabilities:** git operations, npm install, file editing, gemini (self), claude (delegate)
- **Restrictions:** Runs only inside the WSL environment

### Gemini Windows Agent (Standalone) (ID: "gemini_windows")
- **Description:** Gemini, running in native Windows (PowerShell). Can only access Windows tools.
- **GUI Support:** Yes
- **Capabilities:** git operations, npm install, file editing, gemini (self)
- **Restrictions:** Runs only in native Windows, Cannot access WSL-only tools like claude



## Directory Structure

```
├── docs/
├── logs/
├── migrations/
├── public/
│   └── js/
│       └── admin_pairing.js
├── scripts/
├── services/
│   └── eckwms-global/
│       ├── src/
│       │   ├── models/
│       │   ├── services/
│       │   └── utils/
│       └── NGINX_SETUP.md
├── src/
│   ├── server/
│   │   └── local/
│   │       ├── config/
│   │       ├── html/
│   │       ├── integrations/
│   │       │   └── logistics/
│   │       │       └── drivers/
│   │       │           └── opal/
│   │       ├── locales/
│   │       │   ├── ar/
│   │       │   ├── bg/
│   │       │   ├── cs/
│   │       │   ├── da/
│   │       │   ├── de/
│   │       │   ├── ei/
│   │       │   ├── el/
│   │       │   ├── en/
│   │       │   ├── es/
│   │       │   ├── et/
│   │       │   ├── eu/
│   │       │   ├── fi/
│   │       │   ├── fr/
│   │       │   ├── ga/
│   │       │   ├── he/
│   │       │   ├── hr/
│   │       │   ├── hu/
│   │       │   ├── it/
│   │       │   ├── ja/
│   │       │   ├── ko/
│   │       │   ├── lt/
│   │       │   ├── lv/
│   │       │   ├── mt/
│   │       │   ├── nl/
│   │       │   ├── pl/
│   │       │   ├── pt/
│   │       │   ├── ro/
│   │       │   ├── ru/
│   │       │   ├── sk/
│   │       │   ├── sl/
│   │       │   ├── sr/
│   │       │   ├── sv/
│   │       │   ├── tr/
│   │       │   ├── uk/
│   │       │   ├── un/
│   │       │   └── zh/
│   │       ├── middleware/
│   │       ├── routes/
│   │       │   └── scan.js
│   │       ├── services/
│   │       ├── utils/
│   │       │   └── scanHandler.js
│   │       ├── views/
│   │       │   └── admin/
│   │       └── server.js
│   └── shared/
│       ├── models/
│       │   └── postgresql/
│       └── utils/
├── workflows/
└── ANDROID_INTEGRATION.md
```

--- File: /src/server/local/server.js ---

// Main Express application for eckwms
require('dotenv').config(); // Убедись, что это вызывается очень рано

const express = require('express');
const path = require('path');
const fs = require('fs');
const { resolve } = require('path');
const app = express();
const bodyParser = require('body-parser');
const helmet = require('helmet');
const { createSecretJwtKey } = require('../../shared/utils/encryption'); // Убедись, что это используется правильно или удали, если ключи создаются внутри utils/encryption.js
const { appendFile } = require('fs/promises');
// Убрал 'express-session' и 'connect-pg-simple' т.к. JWT используется для auth API
const passport = require('passport');
const initI18n = require('./middleware/i18n');
const { translationQueue } = require('./middleware/i18n'); // Убедись, что используется
const createLanguageMiddleware = require('./middleware/languageMiddleware');
const { requireAdmin } = require('./middleware/auth'); // Middleware auth
const i18next = require('i18next');
const createHtmlTranslationInterceptor = require('./middleware/htmlTranslationInterceptor');
const { createProxyMiddleware } = require('http-proxy-middleware'); // <-- ДОБАВЛЕНО для NodeBB прокси
const { collectAndReportDiagnostics } = require('./utils/startupDiagnostics');

// Import routes
const apiRoutes = require('./routes/api');
const rmaRoutes = require('./routes/rma');
const statusRoutes = require('./routes/status');
const adminRoutes = require('./routes/admin');
const authRoutes = require('./routes/auth');
const translationApiRoutes = require('./routes/translation-api');
const translationAdminRoutes = require('./routes/translation-admin');
const eckwmsRoutes = require('./routes/eckwms');
// Убрал mavenProxyRoutes, так как сказали, что он нерелевантен для проксирования сайта
// const mavenProxyRoutes = require('./routes/mavenProxy'); // Если все же нужен, верни

// NEW: Import scan routes
const scanRoutes = require('./routes/scan');

// NEW: Import upload routes
const uploadRoutes = require('./routes/upload');

// NEW: Import setup routes for device pairing
const setupRoutes = require('./routes/setup');

// Import middleware
const { errorHandler, requestLogger } = require('./middleware');

// Import models (Legacy - возможно, часть уже не нужна при переходе на PG)
const { Betruger, User, Order, Place, Box, Item, Dict } = require('../../shared/models');
const { writeLargeMapToFile } = require('./utils/fileUtils');

// Import PostgreSQL models
const db = require('../../shared/models/postgresql');

// Global variables (Подумай, можно ли избавиться от части глобальных переменных, особенно для данных, которые теперь в PG)
// global.dict = new Dict(''); // Вероятно, можно заменить на работу с PG
// global.dicts = new Map(); // Вероятно, можно заменить на работу с PG
global.user = new User(''); // Используется ли еще старая модель? UserAuth из PG теперь основная.
// ... и так далее для других глобальных переменных ...
global.users = new Map();
global.orders = new Map();
global.uppers = new Map();
global.classes = new Map();
global.items = new Map();
global.boxes = new Map();
global.places = new Map();
global.runOnServer = Object.hasOwn(process.env, 'pm_id');
global.baseDirectory = __dirname + '/';

// Инициализация JWT секрета глобально (ВАЖНО!)
// Убедись, что JWT_SECRET в .env ЕСТЬ и он тот же, что используется в utils/encryption.js
if (!process.env.JWT_SECRET) {
    throw new Error("Критическая ошибка: JWT_SECRET не найден в .env!");
}
global.secretJwt = process.env.JWT_SECRET; // Используется в middleware/auth.js для jwt.sign/verify

// Serial numbers for items/boxes/places (Legacy - возможно, можно перенести в базу)
global.serialIi = 999999999999999;
global.serialI = 1;
global.serialB = 1;
global.serialP = 1;

// --- Логгирование запроса (оставлено) ---
app.use((req, res, next) => {
    console.log('============================= Request Start Point =========================================');
    next();
});

// --- Безопасность ---
app.use(helmet({
    contentSecurityPolicy: false, // Подумай, можно ли включить и настроить CSP
    crossOriginEmbedderPolicy: false // Возможно, тоже стоит настроить
}));

// --- Основные Middleware ---
app.use(express.json()); // Для JSON тел запросов
app.use(express.urlencoded({ extended: true })); // Для URL-encoded тел запросов
app.use(bodyParser.text({ type: 'text/html' })); // Для text/html тел запросов (используется?)

app.use(requestLogger); // Логгер запросов

// --- Инициализация Passport (для JWT стратегии) ---
const configPassport = require('./config/passport');
configPassport(passport); // Передаем экземпляр passport для конфигурации стратегии 'jwt'
app.use(passport.initialize()); // Passport инициализация

// --- Middleware для языка и i18n ---
app.use(initI18n()); // i18n инициализация
app.use(createHtmlTranslationInterceptor(i18next)); // Перехватчик HTML для переводов
app.use(createLanguageMiddleware()); // Установка языка в заголовки

// --- Middleware для контроля кеширования (оставлено) ---
app.use((req, res, next) => {
    res.set({
      'Cache-Control': 'no-store, no-cache, must-revalidate, private, max-age=0',
      'Pragma': 'no-cache',
      'Expires': 0,
      'Surrogate-Control': 'no-store',
      'ETag': `W/"${Date.now().toString()}"`,
      'Last-Modified': new Date().toUTCString()
    });
    next();
  });

// --- Статические файлы (после middleware кеширования) ---
app.use(express.static(path.join(__dirname, '../../../public'), {
    index: false,
    etag: false,
    lastModified: false,
    maxAge: 0,
    cacheControl: false
}));

// --- ПРОКСИРОВАНИЕ ДЛЯ NODEBB ---
const nodebbTarget = process.env.NODEBB_URL || 'http://localhost:4567'; // URL вашего NodeBB из .env или по умолчанию
const nodebbProxyOptions = {
  target: nodebbTarget,
  changeOrigin: true, // Нужно для корректной работы cookies/заголовков между доменами/портами
  ws: true,           // ВАЖНО: Включает проксирование WebSocket для чата и уведомлений NodeBB
  pathRewrite: {
    '^/forum': '',    // Убираем '/forum' из URL перед отправкой в NodeBB
                     // (NodeBB будет думать, что работает в корне '/')
                     // Если вы настроите NodeBB на работу с base_url '/forum', это можно убрать.
  },
  logLevel: process.env.NODE_ENV === 'development' ? 'debug' : 'info', // Логирование для отладки
  onError: (err, req, res) => { // Обработка ошибок прокси
    console.error('[NodeBB Proxy] Ошибка прокси:', err);
    if (res && !res.headersSent) {
        res.writeHead(502, { 'Content-Type': 'text/plain' });
    }
    if (res && !res.writableEnded) {
      res.end('Proxy Error: Could not connect to NodeBB service.');
    }
  }
};

// Применяем прокси ко всем запросам, начинающимся с /forum
app.use('/forum', createProxyMiddleware(nodebbProxyOptions));
console.log(`[NodeBB Proxy] Настроено проксирование /forum -> ${nodebbTarget}`);
// --- КОНЕЦ ПРОКСИРОВАНИЯ NODEBB ---

// --- Маршруты приложения ---
app.use('/api', apiRoutes);
app.use('/rma', rmaRoutes);
app.use('/status', statusRoutes);
app.use('/admin', adminRoutes); // Возможно, стоит защитить через requireAdmin глобально здесь?
app.use('/auth', authRoutes);
app.use('/api', translationApiRoutes); // Дублируется '/api', убедись, что нет конфликтов
app.use('/translation-admin', requireAdmin, translationAdminRoutes); // Защищено админкой
app.use('/ECK', eckwmsRoutes);
app.use('/ECK/api/upload', uploadRoutes);
app.use('/api/internal', setupRoutes); // Device pairing endpoints
// app.use('/nexus', mavenProxyRoutes); // Если нужен Maven Proxy, верни

// Legacy scan routes removed - use /eckwms/api/scan instead with the new intelligent buffer architecture
// app.use('/api/scan', scanRoutes);

// --- Основной маршрут для SPA ---
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'html', 'index.html'));
});


// Health check endpoint for client connectivity testing
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', server: 'local' });
});
// --- Маршрут для JWT верификации (пример, возможно, не нужен) ---
// Если используется только для отладки, можно удалить или защитить.
// Сейчас он использует глобальные переменные, что не идеально.
app.get('/jwt/:token', (req, res) => {
    const { token } = req.params;
    res.status(200);
    res.setHeader('Content-Type', 'text/html');
    try {
        // Используй verifyJWT из твоего модуля encryption, а не из временного require
        const { verifyJWT } = require('../../shared/utils/encryption'); // Предполагается, что она экспортирована
        const payload = verifyJWT(token); // Используем секрет, заданный глобально

        if (!payload) {
           return res.send('Invalid or expired token.');
        }

        // Логика ниже сильно зависит от старых глобальных переменных (orders)
        // Ее нужно адаптировать или удалить, если она больше не нужна
        const { prettyPrintObject, maskObjectFields } = require('./utils/formatUtils');
        const fieldsToMask = ["comp", "pers", "str", "cem", "iem"]; // Старые поля?
        // Пример: попробуем найти пользователя по ID из токена
        // const user = await db.UserAuth.findByPk(payload.userId); // Нужен async
        // const maskedObj = user ? maskObjectFields(user.toJSON(), fieldsToMask) : { message: "User not found or legacy data missing" };

        // Заглушка, пока не ясно, что должно отображаться
         const maskedObj = payload; // Пока просто покажем payload

        res.send('<div style="width: min-content;">' + prettyPrintObject(maskedObj) + '</div><br><br><a href="https://m3.repair/" style="color:#1e2071;">M3 Mobile GmbH Homepage</a>');
    } catch (error) {
        console.error("JWT verification route error:", error);
        res.send(' Nice try, but an error occurred.');
    }
});

// --- Маршрут для админки переводов (защищенный) ---
app.get('/admin/translations', requireAdmin, (req, res) => {
    res.sendFile(path.join(__dirname, 'html/admin/translations.html'));
});

// --- Основной POST обработчик (Legacy? Используется ли еще?) ---
// Этот обработчик выглядит как часть старой системы. Если он не нужен, удали.
// Если нужен, нужно его адаптировать под новую структуру данных.
app.post('/', async (req, res) => {
    try {
        const parsedData = req.body;

        if (parsedData.dest === 'csv') {
            console.warn("CSV export endpoint '/' triggered. Uses legacy global data.");
            const csvData = await generateCsvData(); // Использует глобальные 'boxes'
            res.writeHead(200, {
                'Content-Type': 'text/csv',
                'Content-Disposition': 'attachment; filename="export.csv"',
                'Content-Length': Buffer.byteLength(csvData) // Используй Buffer.byteLength для корректной длины
            });
            res.end(csvData);
        } else {
            console.warn("HTML parsing endpoint '/' triggered. Uses legacy parser.");
            const { parseHtml } = require('./utils/htmlParser'); // Старый парсер?
            const htmlContent = await parseHtml(parsedData); // Использует старую логику?
            res.status(200).send(htmlContent);
        }
    } catch (error) {
        console.error("Error in main POST handler:", error);
        res.status(500).send('Server error: ' + error.message);
    }
});

// --- Internal API endpoint for global server ---
// This endpoint provides public-safe data for items/boxes/orders
app.get('/api/internal/public-data/:id', (req, res) => {
    const { id } = req.params;

    console.log(`[Local Server] Internal API request for ID: ${id}`);

    try {
        // Check if ID exists in any of the legacy global maps
        let data = null;
        let type = null;

        // Check items
        if (global.items && global.items.has(id)) {
            const item = global.items.get(id);
            type = 'item';
            data = {
                id: id,
                type: type,
                model: item.mod || 'Unknown',
                status: item.status || 'Unknown',
                timestamp: item.timestamp || new Date().toISOString()
            };
        }
        // Check boxes
        else if (global.boxes && global.boxes.has(id)) {
            const box = global.boxes.get(id);
            type = 'box';
            data = {
                id: id,
                type: type,
                status: box.status || 'Unknown',
                timestamp: box.timestamp || new Date().toISOString()
            };
        }
        // Check orders
        else if (global.orders && global.orders.has(id)) {
            const order = global.orders.get(id);
            type = 'order';
            data = {
                id: id,
                type: type,
                status: order.status || 'Unknown',
                timestamp: order.timestamp || new Date().toISOString()
            };
        }

        if (data) {
            console.log(`[Local Server] Found ${type} with ID: ${id}`);
            return res.json(data);
        } else {
            console.log(`[Local Server] No data found for ID: ${id}`);
            return res.status(404).json({
                error: 'Item not found',
                message: 'No information available for this code.'
            });
        }
    } catch (error) {
        console.error('[Local Server] Error in internal API:', error);
        return res.status(500).json({
            error: 'Internal server error',
            message: 'An error occurred while retrieving information.'
        });
    }
});

// --- Обработчик ошибок (должен быть последним) ---
app.use(errorHandler);

// --- Вспомогательные функции (Legacy) ---
// Логгирование в файл (оставлено, но можно рассмотреть более современные логгеры)
async function writeLog(str) {
    const dateTemp = new Date(); // Используем локальное время? Или UTC?
    const logDir = resolve('./logs');
    if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
    }
    // Формат имени файла ГГММ.txt
    const filename = `${dateTemp.getFullYear().toString().slice(-2)}${('0' + (dateTemp.getMonth() + 1)).slice(-2)}.txt`;
    const timestamp = `${dateTemp.getDate()}_${dateTemp.getHours()}:${dateTemp.getMinutes()}:${dateTemp.getSeconds()}`;
    const memoryUsage = Object.values(process.memoryUsage()).map(v => `${(v / 1024 / 1024).toFixed(2)}MB`).join(', ');
    return appendFile(resolve(logDir, filename), `${str}\tMemory: ${memoryUsage}\tTimestamp: ${timestamp}\n`);
}

// Генерация CSV (использует глобальные переменные - legacy)
async function generateCsvData() {
    let csv = 'SN /PN;Model;IN DATE;Out Date;Customer;SKU;email;Address;Zip Code;City;Complaint;Verification;Cause;Result;Shipping;Invoice number;Special note; warranty;condition;Used New Parts;Used Refurbished Parts\n';
    console.warn("generateCsvData relies on global 'boxes'. Data might be stale or incomplete.");
    // Логика генерации CSV сильно зависит от структуры глобальных 'boxes'
    // Нужно переписать для работы с данными из PostgreSQL
    boxes.forEach((element) => {
        let packIn = false;
        let packOut = false;
        element.loc?.forEach((locElement) => {
            if (locElement[0] == 'p000000000000000030') packIn = locElement[1];
            if (locElement[0] == 'p000000000000000060') packOut = locElement[1];
        });

        if (packIn || packOut) {
            // TODO: Implement CSV generation logic based on element structure
          // This needs to be adapted to the new data source (PostgreSQL)
        }
    });
    return csv;
}

// --- Инициализация приложения ---
async function initialize() {
    // Убрал legacy dataInit функции, если данные теперь в PG
    // const { initialisation, classesUpdate, upperUpdate } = require('./utils/dataInit');

    try {
        // 1. Инициализация PostgreSQL
        await db.sequelize.authenticate();
        console.log('PostgreSQL connection established successfully.');

        // Синхронизация моделей (только в development)
        if (process.env.NODE_ENV === 'development') {
            const alterDb = process.env.DB_ALTER === 'true';
            console.log(`Syncing PostgreSQL models (alter: ${alterDb})...`);
            await db.sequelize.sync({ alter: alterDb });
            console.log('PostgreSQL models synchronized.');
        }

        // 2. Инициализация legacy данных (если все еще нужны)
        // Подумай, нужно ли это еще, если данные перенесены в PG
        if (fs.existsSync(resolve(baseDirectory, 'base/users.json'))) { // Пример проверки
             console.log('Attempting to initialize legacy data from JSON files...');
             // await initialisation(baseDirectory); // Вызов старой инициализации
             console.log('Legacy data initialization skipped or completed.');
        } else {
             console.log('Legacy JSON files not found, skipping legacy initialization.');
        }


        await writeLog('Server startup initiated.'); // Лог запуска

        // Убрал classesUpdate() и upperUpdate(), если это часть legacy
        // classesUpdate();
        // upperUpdate();

        // 3. Настройка Graceful Shutdown
        process.on('SIGINT', async () => {
            console.log('\nReceived SIGINT. Shutting down gracefully...');
            await logOut(baseDirectory); // Сохранение legacy данных (если нужно)
            await db.sequelize.close(); // Закрытие соединения с PG
            console.log('PostgreSQL connection closed.');
            process.exit(0);
        });
        process.on('SIGTERM', async () => { // Также обрабатываем SIGTERM
            console.log('\nReceived SIGTERM. Shutting down gracefully...');
            await logOut(baseDirectory);
            await db.sequelize.close();
            console.log('PostgreSQL connection closed.');
            process.exit(0);
        });

        // 4. Запуск сервера
        const PORT = process.env.LOCAL_SERVER_PORT || process.env.PORT || 3100;
        app.listen(PORT, () => {
            console.log(`eckwms server running on port ${PORT} in ${process.env.NODE_ENV} mode.`);
            writeLog('Server started successfully.'); // Лог успешного запуска

            // Report diagnostics to global server on startup
            if (process.env.NODE_ENV !== 'development-no-sync') { // Add a flag to disable sync for simple testing
                collectAndReportDiagnostics();
            }
        });

    } catch (err) {
        console.error('FATAL ERROR: Failed to initialize application:', err);
        writeLog(`FATAL ERROR during initialization: ${err.message || err}`);
        process.exit(1); // Выход при фатальной ошибке инициализации
    }
}

// --- Функция сохранения Legacy данных при выходе (если нужно) ---
async function logOut(mainDirectory) {
    console.log('Saving legacy data to JSON files (if applicable)...');
    const basePath = resolve(mainDirectory, 'base');
    try {
        // Проверяем существование папки перед записью
        if (!fs.existsSync(basePath)) {
            console.warn(`Directory ${basePath} not found. Skipping legacy data save.`);
            return;
        }
        // Оборачиваем каждую запись в try/catch, чтобы одна ошибка не прервала все
        try { await writeLargeMapToFile(users, resolve(basePath, 'users.json')); } catch(e) { console.error('Error saving users.json:', e); }
        try { await writeLargeMapToFile(orders, resolve(basePath, 'orders.json')); } catch(e) { console.error('Error saving orders.json:', e); }
        try { await writeLargeMapToFile(items, resolve(basePath, 'items.json')); } catch(e) { console.error('Error saving items.json:', e); }
        try { await writeLargeMapToFile(boxes, resolve(basePath, 'boxes.json')); } catch(e) { console.error('Error saving boxes.json:', e); }
        try { await writeLargeMapToFile(places, resolve(basePath, 'places.json')); } catch(e) { console.error('Error saving places.json:', e); }
        try { await writeLargeMapToFile(classes, resolve(basePath, 'classes.json')); } catch(e) { console.error('Error saving classes.json:', e); }
        try { await writeLargeMapToFile(uppers, resolve(basePath, 'uppers.json')); } catch(e) { console.error('Error saving uppers.json:', e); }
        try { await writeLargeMapToFile(dicts, resolve(basePath, 'dicts.json')); } catch(e) { console.error('Error saving dicts.json:', e); }
        try { await fs.promises.writeFile(resolve(basePath, 'ini.json'), JSON.stringify({ serialIi, serialI, serialB, serialP })); } catch(e) { console.error('Error saving ini.json:', e); }

        await writeLog('Server shutdown completed.'); // Лог завершения
        console.log('Legacy data saved.');
    } catch (err) {
        console.error('Error during logOut (saving legacy data):', err);
        writeLog(`Error during logOut: ${err.message || err}`);
    }
}

// --- Запуск инициализации ---
initialize();

module.exports = app; // Экспорт для тестов или других нужд

--- File: /src/server/local/routes/scan.js ---

// routes/scan.js
const express = require('express');
const router = express.Router();
const { processScan } = require('../utils/scanHandler');

// Endpoint for processing scanned barcodes
router.post('/process', async (req, res) => {
    try {
        const { barcode, type, deviceId } = req.body;
        
        if (!barcode) {
            return res.status(400).json({
                success: false,
                text: 'Barcode is required'
            });
        }

        console.log(`Processing scan request for barcode: ${barcode}, type: ${type}, device: ${deviceId}`);
        
        // Process the scan using the scanHandler utility
        const result = await processScan(barcode);
        
        // Add sample images for testing - in a real implementation, these would be dynamically
        // generated based on the scanned item
        // Format the response for the mobile app
        const response = {
            success: true,
            contentType: result.type,
            text: result.message,
            data: result.data,
            buffers: result.buffers,
            device: deviceId,
            type: type || 'unknown'
        };
        
        // Add actual images from your server storage
        // Use real images from the server for any barcode type
        response.images = [
            'https://pda.repair/storage/pics/BK10.webp',
            'https://pda.repair/storage/pics/SL20.webp',
            'https://pda.repair/storage/pics/SM20.webp'
        ];
        
        // Optionally add specific images based on barcode type
        if (barcode.length === 7 && /^\d+$/.test(barcode)) {
            // For 7-digit codes, add additional images
            response.images.push('https://pda.repair/storage/pics/OX10.webp');
            response.images.push('https://pda.repair/storage/pics/US20.webp');
        } else if (barcode.startsWith('b')) {
            // For box barcodes
            response.images.push('https://pda.repair/storage/pics/sm15.webp');
            response.images.push('https://pda.repair/storage/pics/ul20.webp');
        } else if (barcode.startsWith('RMA')) {
            // For RMA codes
            response.images.push('https://pda.repair/storage/pics/frankfurt.avif');
            response.images.push('https://pda.repair/storage/pics/SEN_8281.avif');
        }

        res.json(response);
    } catch (error) {
        console.error('Error processing scan:', error);
        res.status(500).json({
            success: false,
            text: `Server error: ${error.message}`
        });
    }
});

// Sample endpoint for serving images
router.get('/images/:type/:filename', (req, res) => {
    const { type, filename } = req.params;
    
    // In a real implementation, this would fetch actual images.
    // For demo, we'll generate a placeholder image with text
    
    // Return a 404 for 10% of requests to test error handling
    if (Math.random() < 0.1) {
        return res.status(404).send('Image not found');
    }
    
    // Set content type for image response
    res.setHeader('Content-Type', 'image/jpeg');
    
    // This is a placeholder. In a real implementation, 
    // you would serve actual image files from storage
    res.send(`This would be a ${type} image for ${filename}`);
});

module.exports = router;

--- File: /src/server/local/utils/scanHandler.js ---

// utils/scanHandler.js
// Complete implementation with fixes for URL handling and missing imports

// Import required functions from other modules
const { 
    findKnownCode, 
    isBetDirect, 
    disAct, 
    toAct, 
    isAct, 
    addEntryToProperty, 
    addUnicEntryToProperty 
} = require('./dataInit');

// Import encryption utils
const { betrugerUrlDecrypt } = require('../../../shared/utils/encryption');

// Global buffers for active elements
let iTem = [];
let bOx = [];
let pLace = [];

/**
 * Returns current time in UNIX timestamp (seconds)
 */
function unixTime() {
    return Math.floor(Date.now() / 1000);
}

/**
 * Processes a scanned barcode
 * @param {string} barcode - The scanned barcode
 * @param {object} user - User data (if available)
 * @returns {object} Result of processing the barcode
 */
async function processScan(barcode, user = null) {
    let result = {
        type: 'unknown',
        message: '',
        data: {},
        buffers: {
            items: [],
            boxes: [],
            places: []
        }
    };
    
    try {
        let bet = '';
        
        // Handle URL-formatted barcodes first
        if (barcode.startsWith('http://betruger.com/') || barcode.startsWith('https://betruger.com/')) {
            // Extract the code part from the URL
            const code = barcode.split('/').pop();
            console.log(`Extracted code from URL: ${code}`);
            
            // Try to process as a regular code
            bet = findKnownCode(code) || isBetDirect(code);
        }
        // Handle ECK formatted codes 
        else if (barcode.startsWith('ECK') && barcode.length === 76) {
            try {
                bet = betrugerUrlDecrypt(barcode);
                console.log(`Decrypted ECK code: ${bet}`);
            } catch (err) {
                console.error(`Error decrypting ECK code: ${err.message}`);
                // Continue with other methods if decryption fails
            }
        }
        // Try other recognition methods if URL handling didn't work
        if (!bet) {
            bet = findKnownCode(barcode) || isBetDirect(barcode);
        }
        
        // Process the recognized code
        if (bet) {
            const type = bet.slice(0, 1);
            
            switch (type) {
                case 'i': 
                    result = await handleItemBarcode(bet); 
                    break;
                case 'b': 
                    result = await handleBoxBarcode(bet); 
                    break;
                case 'p': 
                    result = await handlePlaceBarcode(bet); 
                    break;
                case 'o': 
                    result = await handleOrderBarcode(bet); 
                    break;
                case 'u': 
                    result = await handleUserBarcode(bet); 
                    break;
                default: 
                    result.message = `Unknown barcode type: ${type}`;
            }
        } else {
            result = await handleUnknownBarcode(barcode);
        }
        
        // Add current buffers to the result
        result.buffers = {
            items: [...iTem],
            boxes: [...bOx],
            places: [...pLace]
        };
        
        // Log the operation
        console.log(`Scan processed: ${barcode} => ${result.type}`);
        if (result.message) {
            console.log(`Message: ${result.message}`);
        }
        
        return result;
    } catch (error) {
        console.error('Error in processScan:', error);
        return {
            type: 'error',
            message: `Error processing scan: ${error.message}`,
            data: {},
            buffers: {
                items: [...iTem],
                boxes: [...bOx],
                places: [...pLace]
            }
        };
    }
}

/**
 * Handles item barcode
 */
async function handleItemBarcode(betTemp) {
    const result = {
        type: 'item',
        message: '',
        data: {}
    };
    
    // Create item if it doesn't exist
    if (!global.items.has(betTemp)) {
        console.log('Create Item ' + betTemp);
        const tempObj = Object.create(global.item);
        tempObj.sn = [betTemp, unixTime()];
        global.items.set(betTemp, tempObj);
        result.message = 'New item created';
    } else {
        const item = global.items.get(betTemp);
        result.data = {
            serialNumber: betTemp,
            created: item.sn[1],
            class: item.cl || 'Unknown',
            actions: item.actn || []
        };
        result.message = 'Item found';
    }
    
    // Manage item buffer
    if (iTem.length) {
        let toChangeI;
        
        if ((toChangeI = iTem.indexOf(toAct(betTemp))) > -1) {
            // Deactivate active elements
            for (let i = toChangeI; i < iTem.length; i++) {
                if (isAct(iTem[i])) {
                    iTem[i] = disAct(iTem[i]);
                }
            }
            result.message = 'Item deactivated';
        } else if ((toChangeI = iTem.indexOf(betTemp)) > -1) {
            // Activate element
            iTem[toChangeI] = toAct(betTemp);
            result.message = 'Item activated';
        } else {
            // Add new active element
            iTem.push(toAct(betTemp));
            result.message = 'Item added to buffer';
        }
    } else {
        // Buffer is empty, add first element
        iTem.push(toAct(betTemp));
        result.message = 'Item added to empty buffer';
    }
    
    return result;
}

/**
 * Handles box barcode
 */
async function handleBoxBarcode(betTemp) {
    const result = {
        type: 'box',
        message: '',
        data: {}
    };
    
    // Create box if it doesn't exist
    if (!global.boxes.has(betTemp)) {
        console.log('Create Box ' + betTemp);
        const tempObj = Object.create(global.box);
        tempObj.sn = [betTemp, unixTime()];
        global.boxes.set(betTemp, tempObj);
        result.message = 'New box created';
    } else {
        const box = global.boxes.get(betTemp);
        result.data = {
            serialNumber: betTemp,
            created: box.sn[1],
            contents: box.cont || []
        };
        result.message = 'Box found';
    }
    
    // Add items to box if item buffer is not empty
    if (iTem.length) {
        for (const it of iTem) {
            addEntryToProperty(global.items, it, [betTemp, unixTime()], 'loc');
            addEntryToProperty(global.boxes, betTemp, [disAct(it), unixTime()], 'cont');
        }
        
        result.message = `${iTem.length} items added to box`;
        // Log operation
        await writeLog(`[${iTem}] (${iTem.length})=> b${betTemp}`);
        
        // Clear item buffer
        iTem.length = 0;
    }
    
    // Manage box buffer
    if (bOx.length) {
        let toChangeB;
        
        if ((toChangeB = bOx.indexOf(toAct(betTemp))) > -1) {
            // Deactivate active elements
            for (let i = toChangeB; i < bOx.length; i++) {
                if (isAct(bOx[i])) {
                    bOx[i] = disAct(bOx[i]);
                }
            }
            result.message += '; Box deactivated';
        } else if ((toChangeB = bOx.indexOf(betTemp)) > -1) {
            // Activate element
            bOx[toChangeB] = toAct(betTemp);
            result.message += '; Box activated';
        } else {
            // Add new active element
            bOx.push(toAct(betTemp));
            result.message += '; Box added to buffer';
        }
    } else {
        // Buffer is empty, add first element
        bOx.push(toAct(betTemp));
        result.message += '; Box added to empty buffer';
    }
    
    return result;
}

/**
 * Handles place barcode
 */
async function handlePlaceBarcode(betTemp) {
    const result = {
        type: 'place',
        message: '',
        data: {}
    };
    
    // Implementation similar to handleBoxBarcode...
    // Shortened for brevity, implement full logic as in your original code
    
    return result;
}

/**
 * Handles order barcode
 */
async function handleOrderBarcode(betTemp) {
    const result = {
        type: 'order',
        message: '',
        data: {}
    };
    
    // Implementation similar to previous handlers...
    // Shortened for brevity, implement full logic as in your original code
    
    return result;
}

/**
 * Handles user barcode
 */
async function handleUserBarcode(betTemp) {
    const result = {
        type: 'user',
        message: '',
        data: {}
    };
    
    // Implementation similar to previous handlers...
    // Shortened for brevity, implement full logic as in your original code
    
    return result;
}

/**
 * Handles unknown barcode
 */
async function handleUnknownBarcode(barcode) {
    const result = {
        type: 'unknown',
        message: '',
        data: {
            barcode
        }
    };
    
    if (iTem.length) {
        // Item buffer is not empty
        const cla = global.classes.get(barcode);
        
        if (cla) {
            // Barcode is a class
            Object.setPrototypeOf(global.items.get(disAct(iTem[iTem.length - 1])), cla);
            global.items.get(disAct(iTem[iTem.length - 1])).cl = barcode;
            
            result.message = `Class '${barcode}' applied to item`;
            result.type = 'class';
            result.data.class = barcode;
        } else {
            // Barcode is not a class, add it to brc array
            const itemKey = disAct(iTem[iTem.length - 1]);
            if (!Object.hasOwn(global.items.get(itemKey), 'brc')) {
                global.items.get(itemKey).brc = [];
            }
            global.items.get(itemKey).brc.push(barcode);
            
            result.message = `Barcode '${barcode}' added to item's barcodes`;
            result.type = 'item_barcode';
            
            await writeLog(`${barcode} => ${itemKey}`);
        }
    } else if (bOx.length) {
        // Item buffer is empty, but box buffer is not
        const boxKey = disAct(bOx[bOx.length - 1]);
        if (!Object.hasOwn(global.boxes.get(boxKey), 'brc')) {
            global.boxes.get(boxKey).brc = [];
        }
        global.boxes.get(boxKey).brc.push(barcode);
        
        result.message = `Barcode '${barcode}' added to box's barcodes`;
        result.type = 'box_barcode';
        
        await writeLog(`${barcode} => ${boxKey}`);
    } else {
        // Both buffers are empty
        const cl = global.classes.get(barcode);
        
        if (cl) {
            result.message = `Class '${barcode}' found but no items in buffer`;
            result.type = 'class';
            result.data.class = barcode;
        } else {
            result.message = `Unknown barcode '${barcode}'`;
        }
    }
    
    return result;
}

/**
 * Logs operation to file
 */
async function writeLog(str) {
    try {
        const { appendFile } = require('fs/promises');
        const { resolve } = require('path');
        const dateTemp = new Date(Date.now());
        const logDir = resolve('./logs');
        
        // Create directory if it doesn't exist
        const fs = require('fs');
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
        
        const filename = `${dateTemp.getUTCFullYear().toString().slice(-2)}${('00' + (dateTemp.getUTCMonth() + 1)).slice(-2)}.txt`;
        await appendFile(resolve(`./logs/${filename}`), `${str}\t\t\t\t\t${dateTemp.getUTCDate()}_${dateTemp.getUTCHours()}:${dateTemp.getUTCMinutes()}:${dateTemp.getUTCSeconds()}\n`);
    } catch (error) {
        console.error('Error writing log:', error);
    }
}

module.exports = {
    processScan
};

--- File: /services/eckwms-global/NGINX_SETUP.md ---

# eckWMS Global Server - Nginx Configuration

## Текущая конфигурация Nginx

Этот документ содержит **реальные** файлы конфигурации Nginx, используемые на продакшн сервере для `pda.repair` и микросервиса `eckwms-global`.

---

## 1. Основной конфиг Nginx

**Файл**: `/etc/nginx/nginx.conf`

```nginx
user www-data;
worker_processes auto;
pid /run/nginx.pid;
error_log /var/log/nginx/error.log;
include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 768;
}

http {
    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ssl_protocols TLSv1 TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;

    access_log /var/log/nginx/access.log;

    gzip on;

    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
```

---

## 2. Конфигурация для pda.repair (с eckWMS)

**Файл**: `/etc/nginx/sites-available/pda.repair.conf`

```nginx
server {
    server_name pda.repair www.pda.repair;


    location /.well-known/acme-challenge/ { allow all; }

    # Certbot добавит сюда редирект на HTTPS

    listen [::]:443 ssl; # managed by Certbot
    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/pda.repair/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/pda.repair/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot


 # --- Логирование (оставляем как есть) ---
    access_log /var/log/nginx/pda.repair.access.log;
    error_log /var/log/nginx/pda.repair.error.log warn;

    # --- Заголовки безопасности (оставляем как есть) ---
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # --- Обработка запросов (оставляем как есть) ---

# 1. Обрабатываем ТОЛЬКО статические ассеты (кроме HTML)
location ~* \.(?:css|js|png|jpg|jpeg|webp|avif|gif|ico|svg|woff|woff2|ttf|eot)$ {
    root /var/www/pda.repair/html;
    try_files $uri =404;
    expires max;
    add_header Cache-Control public;
}

# 2. Явно обрабатываем HTML файлы - отправляем их на Node.js
location ~* \.html$ {
    proxy_pass http://localhost:3000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection 'upgrade';
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_cache_bypass $http_upgrade;
}

# 2.5. Проксируем запросы к микросервису eckWMS Global Server
location /ECK/ {
    proxy_pass http://localhost:8080/ECK/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection 'upgrade';
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_cache_bypass $http_upgrade;
}

# 3. Все остальные запросы проксируем на Node.js
location / {
    proxy_pass http://localhost:3000;
    proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }



}

server {
    if ($host = www.pda.repair) {
        return 301 https://$host$request_uri;
    } # managed by Certbot


    # listen 443 ssl http2; # Будет добавлено Certbot
    # listen [::]:443 ssl http2; # Будет добавлено Certbot
    server_name pda.repair www.pda.repair;

    # Корень для файлов этого сайта
    root /var/www/pda.repair/html;
    index index.html index.htm;

    # SSL настройки будут добавлены Certbot
    # ssl_certificate ...;
    # ssl_certificate_key ...;
    # include /etc/letsencrypt/options-ssl-nginx.conf;
    # ssl_dhparam ...;

    # Логи для этого сайта
    access_log /var/log/nginx/pda.repair.access.log;
    error_log /var/log/nginx/pda.repair.error.log warn;

    # Заголовки безопасности
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Обработка запросов к статическим файлам
    location / {
        try_files $uri $uri/ =404;
    }


}
server {
    if ($host = pda.repair) {
        return 301 https://$host$request_uri;
    } # managed by Certbot


    listen 80;
    listen [::]:80;
    server_name pda.repair www.pda.repair;
    return 404; # managed by Certbot


}
```

---

## Анализ конфигурации

### Структура серверов

1. **Главный HTTPS сервер** (строки 1-77)
   - Слушает порты 443 (SSL)
   - SSL сертификаты от Let's Encrypt (Certbot)
   - Обрабатывает все HTTPS запросы

2. **Редирект сервер** (строки 79-114)
   - Редиректит www.pda.repair → pda.repair

3. **HTTP сервер** (строки 115-128)
   - Редиректит HTTP → HTTPS

### Маршрутизация запросов

#### 1. Статические файлы (CSS, JS, изображения)
```nginx
location ~* \.(?:css|js|png|jpg|jpeg|webp|avif|gif|ico|svg|woff|woff2|ttf|eot)$ {
    root /var/www/pda.repair/html;
    try_files $uri =404;
    expires max;
    add_header Cache-Control public;
}
```
- Обслуживаются напрямую из `/var/www/pda.repair/html`
- Максимальное кеширование
- Без проксирования

#### 2. HTML файлы
```nginx
location ~* \.html$ {
    proxy_pass http://localhost:3000;
    # ... proxy headers ...
}
```
- Проксируются на Node.js сервер (порт 3000)
- Вероятно, для SSR или динамической генерации

#### 3. **eckWMS Global Server** (КРИТИЧНО)
```nginx
location /ECK/ {
    proxy_pass http://localhost:8080/ECK/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection 'upgrade';
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_cache_bypass $http_upgrade;
}
```

**Важные детали:**
- Все запросы к `/ECK/*` идут на микросервис `eckwms-global` (порт 8080)
- Заголовки `X-Real-IP` и `X-Forwarded-For` передают реальный IP клиента
- Поддержка WebSocket (Upgrade, Connection headers)
- `proxy_cache_bypass` отключает кеширование для динамических данных

#### 4. Все остальные запросы
```nginx
location / {
    proxy_pass http://localhost:3000;
    # ... proxy headers ...
}
```
- Проксируются на основной Node.js сервер pda.repair

---

## Важные proxy headers для eckWMS

Эти заголовки критичны для корректной работы определения IP:

| Header | Значение | Назначение |
|--------|----------|------------|
| `Host` | `$host` | Оригинальный домен (pda.repair) |
| `X-Real-IP` | `$remote_addr` | IP клиента (один адрес) |
| `X-Forwarded-For` | `$proxy_add_x_forwarded_for` | Цепочка прокси + клиент |
| `X-Forwarded-Proto` | `$scheme` | https/http |
| `Upgrade` | `$http_upgrade` | Для WebSocket |
| `Connection` | `'upgrade'` | Для WebSocket |

### Почему это работает с `app.set('trust proxy', 1)`

В `server.js` настроено:
```javascript
app.set('trust proxy', 1);
```

Это заставляет Express:
1. Читать `X-Forwarded-For` заголовок
2. Использовать первый IP из цепочки как `req.ip`
3. Игнорировать IP Nginx (127.0.0.1)

---

## Endpoints eckWMS Global Server

Все endpoints доступны через `https://pda.repair/ECK/...`:

- `GET /ECK/HEALTH` - Health check
- `GET /ECK/PROXY/HEALTH` - Proxy health (без требования заголовков)
- `POST /ECK/API/INTERNAL/REGISTER-INSTANCE` - Регистрация инстанса
- `POST /ECK/API/INTERNAL/GET-INSTANCE-INFO` - Получение информации об инстансе
- `POST /ECK/API/DEVICE/REGISTER` - Регистрация устройства
- `POST /ECK/PROXY` - Прокси эндпоинт (требует `X-eckWMS-Target-Url`)
- `GET /ECK/:code` - QR коды

---

## Безопасность

### Текущие настройки безопасности

```nginx
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
```

- **X-Frame-Options**: Защита от clickjacking
- **X-Content-Type-Options**: Запрет MIME sniffing
- **Referrer-Policy**: Контроль передачи referrer

### SSL/TLS

- **Сертификаты**: Let's Encrypt (автообновление через Certbot)
- **Протоколы**: TLSv1, TLSv1.2, TLSv1.3
- **Конфиг**: `/etc/letsencrypt/options-ssl-nginx.conf`

---

## Логирование

### Логи Nginx

```nginx
access_log /var/log/nginx/pda.repair.access.log;
error_log /var/log/nginx/pda.repair.error.log warn;
```

### Логи приложения

- **eckWMS Global**: `pm2 logs eckwms-global`
- **Node.js (pda.repair)**: `pm2 logs pda.repair`

---

## Проверка конфигурации

```bash
# Проверка синтаксиса
nginx -t

# Перезагрузка без даунтайма
nginx -s reload
# или
systemctl reload nginx

# Проверка активных портов
netstat -tulpn | grep nginx
netstat -tulpn | grep 8080
netstat -tulpn | grep 3000

# Тест endpoints
curl -I https://pda.repair/ECK/HEALTH
curl -I https://pda.repair/ECK/PROXY/HEALTH
```

---

## Управление сервисами

### PM2 процессы

```bash
# Список процессов
pm2 list

# Логи eckWMS
pm2 logs eckwms-global

# Рестарт
pm2 restart eckwms-global

# Статус
pm2 show eckwms-global
```

### Nginx

```bash
# Статус
systemctl status nginx

# Рестарт
systemctl restart nginx

# Reload конфигурации
systemctl reload nginx
```

---

## Файловая структура

```
/etc/nginx/
├── nginx.conf                      # Главный конфиг
├── sites-available/
│   └── pda.repair.conf            # Конфиг pda.repair + eckWMS
├── sites-enabled/
│   └── pda.repair.conf -> ../sites-available/pda.repair.conf

/var/www/
├── pda.repair/
│   └── html/                       # Статические файлы сайта
└── eckwms/
    └── services/
        └── eckwms-global/
            ├── src/server.js       # Express приложение (порт 8080)
            ├── .env                # Переменные окружения
            └── NGINX_SETUP.md      # Этот файл

/var/log/nginx/
├── pda.repair.access.log          # Access логи
├── pda.repair.error.log           # Error логи
└── error.log                       # Общие ошибки Nginx

/etc/letsencrypt/
└── live/
    └── pda.repair/
        ├── fullchain.pem           # SSL сертификат
        └── privkey.pem             # Приватный ключ
```

---

## Диагностика проблем

### Проблема: 502 Bad Gateway на /ECK/*

**Проверить:**
```bash
# Работает ли приложение?
pm2 list | grep eckwms-global

# Слушает ли порт 8080?
netstat -tulpn | grep 8080

# Есть ли ошибки в логах?
pm2 logs eckwms-global --lines 50
tail -50 /var/log/nginx/pda.repair.error.log
```

### Проблема: Неправильный IP в логах

**Проверить:**
```bash
# Включен ли trust proxy?
grep "trust proxy" /var/www/eckwms/services/eckwms-global/src/server.js

# Передает ли Nginx заголовки?
curl -v https://pda.repair/ECK/HEALTH 2>&1 | grep -i forward

# Что видит приложение?
pm2 logs eckwms-global | grep "IP Detection"
```

---

## История изменений

- **2025-12-16**: Добавлена настройка `trust proxy` в server.js
- **2025-12-16**: Обновлены все API пути на uppercase (HEALTH, PROXY, API)
- **2025-12-16**: Добавлен bypass для /PROXY/HEALTH без заголовков
- **2025-04-04**: Базовая конфигурация Nginx для pda.repair
- **Ранее**: Интеграция eckWMS Global Server на порт 8080

---

**Архитектор**: Используй эту информацию для понимания текущей инфраструктуры и планирования изменений.


--- File: /public/js/admin_pairing.js ---

document.addEventListener('DOMContentLoaded', () => {
    const generateBtn = document.getElementById('generate-qr-btn');
    const qrContainer = document.getElementById('qr-container');
    const qrImg = document.getElementById('qr-code-img');
    const statusBox = document.getElementById('status-box');

    // Function to get JWT from localStorage
    function getAuthToken() {
        return localStorage.getItem('auth_token');
    }

    // Generate QR Code
    generateBtn.addEventListener('click', async () => {
        qrContainer.innerHTML = '<p>Generating QR code...</p>';
        qrImg.style.display = 'none';

        const token = getAuthToken();
        if (!token) {
            qrContainer.innerHTML = '<p style="color:red;">Error: You are not authenticated. Please log in again.</p>';
            return;
        }

        try {
            const isVip = document.getElementById('vip-mode-check').checked;
            const url = isVip ? '/api/internal/pairing-qr?type=vip' : '/api/internal/pairing-qr';

            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!response.ok) {
                // Handle 401 Unauthorized - token expired or invalid
                if (response.status === 401) {
                    localStorage.removeItem('auth_token');
                    window.location.href = '/auth/login';
                    return;
                }
                throw new Error(`Server returned status ${response.status}`);
            }

            const data = await response.json();
            qrImg.src = data.qr_code_data_url;
            qrImg.style.display = 'block';
            qrContainer.innerHTML = '';
            qrContainer.appendChild(qrImg);
        } catch (error) {
            console.error('Error generating QR code:', error);
            qrContainer.innerHTML = `<p style="color:red;">Failed to generate QR code: ${error.message}</p>`;
        }
    });

    // Check Global Server Status
    async function checkGlobalServerStatus() {
        try {
            const response = await fetch('/api/internal/global-server-status');
            const data = await response.json();

            if (data.status === 'online') {
                statusBox.className = 'status-box status-online';
                statusBox.textContent = `Global Server is ONLINE.`;
            } else {
                statusBox.className = 'status-box status-offline';
                statusBox.textContent = `Global Server is OFFLINE. Error: ${data.error}`;
            }
        } catch (error) {
            statusBox.className = 'status-box status-offline';
            statusBox.textContent = `Could not reach local API to check global status: ${error.message}`;
        }
    }

    // Initial check and periodic refresh
    checkGlobalServerStatus();
    setInterval(checkGlobalServerStatus, 15000); // Check every 15 seconds
});

// --- Device Management Logic ---

async function loadDevices() {
    const container = document.getElementById('devices-list');
    const token = localStorage.getItem('auth_token');

    try {
        const response = await fetch('/admin/api/devices', {
            headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.status === 401 || response.status === 403) {
            console.warn('Auth failed, redirecting to login');
            window.location.href = '/auth/login';
            return;
        }

        const devices = await response.json();

        if (!Array.isArray(devices)) {
             throw new Error(devices.error || 'Invalid server response (not an array)');
        }

        if (devices.length === 0) {
            container.innerHTML = '<p>No devices registered yet.</p>';
            return;
        }

        let html = `
            <table class="device-table">
                <thead>
                    <tr>
                        <th>Status</th>
                        <th>Device ID / Name</th>
                        <th>Last Seen</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
        `;

        devices.forEach(device => {
            const statusClass = `badge-${device.status}`;
            const name = device.deviceName || 'Unknown Device';
            const lastSeen = new Date(device.updatedAt).toLocaleString();

            let actions = '';
            if (device.status === 'pending') {
                actions += `<button onclick="updateStatus('${device.deviceId}', 'active')" class="btn-action btn-approve">✅ Approve</button>`;
            }
            if (device.status === 'active') {
                actions += `<button onclick="updateStatus('${device.deviceId}', 'blocked')" class="btn-action btn-block">⛔ Block</button>`;
            }
            if (device.status === 'blocked') {
                actions += `<button onclick="updateStatus('${device.deviceId}', 'active')" class="btn-action btn-approve">🔄 Unblock</button>`;
            }
            actions += `<button onclick="deleteDevice('${device.deviceId}', this)" class="btn-action btn-delete">🗑️</button>`;

            html += `
                <tr data-id="${device.deviceId}">
                    <td><span class="badge ${statusClass}">${device.status}</span></td>
                    <td>
                        <strong>${device.deviceId.substring(0, 16)}...</strong><br>
                        <small>${name}</small>
                    </td>
                    <td>${lastSeen}</td>
                    <td>${actions}</td>
                </tr>
            `;
        });

        html += '</tbody></table>';
        container.innerHTML = html;

    } catch (error) {
        container.innerHTML = `<p style="color:red">Error loading devices: ${error.message}</p>`;
    }
}

// --- UX Helpers ---
function showToast(message, onUndo, duration = 5000) {
    const container = document.getElementById('toast-container') || createToastContainer();
    const toast = document.createElement('div');
    toast.className = 'toast';

    const msgSpan = document.createElement('span');
    msgSpan.className = 'toast-message';
    msgSpan.textContent = message;

    const undoBtn = document.createElement('button');
    undoBtn.className = 'toast-undo-btn';
    undoBtn.textContent = '⟲ UNDO';

    // Progress bar
    const progressBar = document.createElement('div');
    progressBar.className = 'toast-progress';
    progressBar.style.animation = `shrink ${duration}ms linear`;

    let isUndone = false;
    let timer = setTimeout(() => {
        if (!isUndone) {
            toast.style.animation = 'fadeOut 0.3s ease-out';
            setTimeout(() => {
                toast.remove();
                onUndo(false); // Timer finished, execute action
            }, 300);
        }
    }, duration);

    undoBtn.onclick = () => {
        isUndone = true;
        clearTimeout(timer);
        toast.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => toast.remove(), 300);
        onUndo(true); // User clicked Undo
    };

    toast.appendChild(msgSpan);
    toast.appendChild(undoBtn);
    toast.appendChild(progressBar);
    container.appendChild(toast);

    // Add shrink animation to CSS dynamically
    if (!document.getElementById('toast-animations')) {
        const style = document.createElement('style');
        style.id = 'toast-animations';
        style.textContent = `
            @keyframes shrink {
                from { transform: scaleX(1); }
                to { transform: scaleX(0); }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translateY(0); }
                to { opacity: 0; transform: translateY(20px); }
            }
        `;
        document.head.appendChild(style);
    }
}

function createToastContainer() {
    const div = document.createElement('div');
    div.id = 'toast-container';
    div.className = 'toast-container';
    document.body.appendChild(div);
    return div;
}

// --- Actions ---
window.updateStatus = async (id, status) => {
    const row = document.querySelector(`tr[data-id='${id}']`);
    if (row) row.style.opacity = '0.5'; // Visual feedback

    showToast(`Changing status to ${status.toUpperCase()}...`, async (isUndo) => {
        if (isUndo) {
            if (row) row.style.opacity = '1';
            return;
        }

        // Execute API call
        const token = localStorage.getItem('auth_token');
        await fetch(`/admin/api/devices/${id}/status`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ status })
        });
        loadDevices();
    }, 4000); // 4 seconds to undo
};

let deleteTimeouts = {};
window.deleteDevice = async (id, btn) => {
    if (btn.classList.contains('btn-confirm-delete')) {
        // Real delete
        const token = localStorage.getItem('auth_token');
        await fetch(`/admin/api/devices/${id}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        loadDevices();
        return;
    }

    // First click - Change to confirm state
    const originalText = btn.innerHTML;
    btn.innerHTML = 'Sure?';
    btn.classList.add('btn-confirm-delete');

    // Reset after 3 seconds if not clicked
    if (deleteTimeouts[id]) clearTimeout(deleteTimeouts[id]);
    deleteTimeouts[id] = setTimeout(() => {
        btn.innerHTML = originalText;
        btn.classList.remove('btn-confirm-delete');
    }, 3000);
};

// Load devices on startup and refresh every 10s
loadDevices();
setInterval(loadDevices, 10000);


--- File: /ANDROID_INTEGRATION.md ---

# eckWMS - Android Client Integration Contract

**Version: 1.0**

This document outlines the technical requirements and API contract for the `eckwms-movfast` Android application to interact with the `eckwms` server ecosystem.

## 1. Core Architectural Concept: Local-First, Global-Fallback

The entire system is designed for maximum reliability and performance. The Android client **MUST** operate in an **offline-first** manner and follow this connectivity strategy:

1.  **Attempt Local Connection:** By default, all API requests should be sent directly to the **Local Server** within the facility's network. This ensures the fastest possible response times.
2.  **Fallback to Global Proxy:** If the Local Server is unreachable (e.g., user is outside the local Wi-Fi, server is down), the client **MUST NOT** show an error. Instead, it must **automatically** retry the same request by sending it to the **Global Server's** proxy endpoint.
3.  **Offline Queue:** If both servers are unreachable, the client **MUST** queue the action (e.g., scan, image upload) in its local database (`SyncQueue`). A background service (`WorkManager`) will periodically attempt to send the queued data once connectivity is restored.

## 2. Client Configuration

The Android application must provide a settings screen where the user can configure two separate URLs:

-   **`LOCAL_SERVER_URL`**: The IP address and port of the server running on the local network (e.g., `http://192.168.1.100:3100`).
-   **`GLOBAL_SERVER_URL`**: The public domain and port of the globally accessible server (e.g., `http://your-domain.com:8080`).

## 3. Key API Endpoints & Payloads

### 3.1. Scan Data Submission

This is the primary endpoint for sending barcode data.

-   **Local Endpoint:** `POST /eckwms/api/scan`
-   **Global Proxy Endpoint:** `POST /api/proxy/eckwms/api/scan`

**Headers:**

-   `Content-Type: application/json`
-   `X-API-Key: {INSTANCE_API_KEY}` (For authentication with the server)

**JSON Payload Example:**

```json
{
  "deviceId": "a1b2c3d4e5f6g7h8",
  "payload": "I700000000002113897",
  "type": "CODE_128",
  "checksum": "a4f3b2c1",
  "priority": 0,
  "orderId": "CS-DE-251108-1" // Optional: If a specific order is active
}
```

-   `deviceId`: Unique identifier of the Android device.
-   `payload`: The raw string data from the scanned barcode.
-   `type`: The barcode symbology (e.g., `CODE_128`, `QR_CODE`).
-   `checksum`: A CRC32 checksum of the `payload` string to ensure data integrity.

### 3.2. Image Upload

Used for uploading photos associated with scans or workflows.

-   **Endpoint:** `POST /api/upload/image` (Works for both local and global servers, as the global server will proxy it if needed).

**Request Type:** `multipart/form-data`

**Form Fields:**

-   `image`: The image file data (e.g., in WebP or JPEG format).
-   `deviceId`: Unique identifier of the Android device.
-   `scanMode`: Context of the capture (e.g., `direct_upload`, `workflow_capture`).
-   `barcodeData`: (Optional) Any barcode data extracted from the image by ML Kit.
-   `imageChecksum`: A CRC32 checksum of the image file bytes to ensure integrity.
-   `orderId`: (Optional) The active order ID to associate the image with.

## 4. Android Application Architecture Requirements

The `eckwms-movfast` application must be structured to support the described functionality and future expansion.

### 4.1. AI-Driven Core

An **`AndroidAgent.kt`** singleton must act as the central orchestrator ('brain') of the application. It is responsible for:
-   Managing and executing workflows.
-   Making decisions about connectivity strategies.
-   Coordinating between different components (UI, Data, Hardware).
-   Providing a clear interface for future integration with a real LLM (like Gemini API).

### 4.2. Local Database (Offline-First)

A local database (using **AndroidX Room**) is mandatory. It must contain at least:
-   **Data Cache:** Tables for caching essential WMS data (`ItemEntity`, `BoxEntity`, etc.) to provide an instant UI experience.
-   **Sync Queue:** A `SyncQueueEntity` table to store all actions performed while offline. Each entry represents a task (e.g., an API call) that needs to be executed once the network is available.

### 4.3. Data & Connectivity Layer

-   A **`WarehouseRepository.kt`** must be created to abstract data sources. UI components should only interact with the repository, which will decide whether to fetch data from the local Room cache or from the network via `ScanApiService`.
-   A **`SyncWorker.kt`** (using `WorkManager`) must be implemented to reliably process the `SyncQueue` in the background, even if the app is closed.

### 4.4. Modular Scanner Drivers

The application must support multiple hardware scanner vendors. This must be achieved through a modular driver architecture:
-   An interface **`ScannerDriver.kt`** will define a common contract for all scanners (`initialize`, `startScan`, `isSupported`, etc.).
-   The existing `XCScannerWrapper.kt` will be refactored into `XCScannerDriver.kt` to implement this interface.
-   A **`ScannerDriverFactory.kt`** will be responsible for detecting the device's hardware at runtime and selecting the appropriate driver. This allows new hardware support (e.g., for Seuic, iData) to be added simply by creating a new driver class.


